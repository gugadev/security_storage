Index: src/main/kotlin/com/pacificoseguros/securitystorage/security_storage/SecurityStoragePlugin.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.pacificoseguros.securitystorage.security_storage\n\nimport android.app.Activity\nimport android.content.Context\nimport android.os.Handler\nimport android.os.Looper\nimport android.security.keystore.KeyPermanentlyInvalidatedException\nimport android.util.Log\nimport androidx.annotation.NonNull\nimport androidx.biometric.BiometricManager\nimport androidx.biometric.BiometricPrompt\nimport androidx.fragment.app.FragmentActivity\nimport com.google.gson.Gson\nimport com.pacificoseguros.securitystorage.security_storage.PreferenceHelper.get\nimport com.pacificoseguros.securitystorage.security_storage.PreferenceHelper.set\n//import com.squareup.moshi.Moshi\n//import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory\nimport io.flutter.embedding.engine.plugins.FlutterPlugin\nimport io.flutter.embedding.engine.plugins.activity.ActivityAware\nimport io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding\nimport io.flutter.plugin.common.MethodCall\nimport io.flutter.plugin.common.MethodChannel\nimport io.flutter.plugin.common.MethodChannel.MethodCallHandler\nimport io.flutter.plugin.common.MethodChannel.Result\nimport io.flutter.plugin.common.PluginRegistry.Registrar\nimport java.nio.charset.Charset\nimport java.security.InvalidAlgorithmParameterException\nimport java.util.concurrent.ExecutorService\nimport java.util.concurrent.Executors\n\n/** SecurityStoragePlugin */\npublic class SecurityStoragePlugin : FlutterPlugin, MethodCallHandler, ActivityAware {\n    /// The MethodChannel that will the communication between Flutter and native Android\n    ///\n    /// This local reference serves to register the plugin with the Flutter Engine and unregister it\n    /// when the Flutter Engine is detached from the Activity\n    private lateinit var channel: MethodChannel\n    private lateinit var context: Context\n    private lateinit var activity: FragmentActivity\n    private lateinit var cryptographyManager: CryptographyManager\n    private lateinit var biometricPrompt: BiometricPrompt\n    private lateinit var promptInfo: BiometricPrompt.PromptInfo\n\n    private val storageItems = mutableMapOf<String, StorageItem>()\n\n    //private  var cryptographyManagers= mutableMapOf<String, CryptographyManager>()\n    override fun onAttachedToEngine(@NonNull flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) {\n        channel = MethodChannel(flutterPluginBinding.getFlutterEngine().getDartExecutor(), \"security_storage\")\n        channel.setMethodCallHandler(this);\n        context = flutterPluginBinding.applicationContext\n        cryptographyManager = CryptographyManager()\n\n    }\n\n    // This static function is optional and equivalent to onAttachedToEngine. It supports the old\n    // pre-Flutter-1.12 Android projects. You are encouraged to continue supporting\n    // plugin registration via this function while apps migrate to use the new Android APIs\n    // post-flutter-1.12 via https://flutter.dev/go/android-project-migration.\n    //\n    // It is encouraged to share logic between onAttachedToEngine and registerWith to keep\n    // them functionally equivalent. Only one of onAttachedToEngine or registerWith will be called\n    // depending on the user's project. onAttachedToEngine or registerWith must both be defined\n    // in the same class.\n    companion object {\n        @JvmStatic\n        fun registerWith(registrar: Registrar) {\n            val channel = MethodChannel(registrar.messenger(), \"security_storage\")\n            channel.setMethodCallHandler(SecurityStoragePlugin())\n            SecurityStoragePlugin().apply {\n                print(\"initialize plugin\")\n            }\n        }\n\n        val executor: ExecutorService = Executors.newSingleThreadExecutor()\n        private val handler: Handler = Handler(Looper.getMainLooper())\n        private const val TAG = \"SecurityStoragePlugin\"\n//        val moshi = Moshi.Builder()\n//                .add(KotlinJsonAdapterFactory())\n//                .build() as Moshi\n        const val PARAM_ANDROID_PROMPT_INFO = \"androidPromptInfo\"\n        const val PARAM_NAME = \"name\"\n        const val PARAM_WRITE_CONTENT = \"content\"\n\n    }\n\n    override fun onMethodCall(@NonNull call: MethodCall, @NonNull result: Result) {\n\n        fun <T> requiredArgument(name: String) =\n                call.argument<T>(name) ?: throw MethodCallException(\n                        \"MissingArgument\",\n                        \"Missing required argument '$name'\"\n                )\n\n        val getAndroidPromptInfo = {\n            val gson = Gson()\n            requiredArgument<Map<String, Any>>(PARAM_ANDROID_PROMPT_INFO).let {\n                gson.fromJson(it ?: \"{}\", AndroidPromptInfo::class.java) ?: throw MethodCallException(\n                    \"BadArgument\",\n                    \"'$PARAM_ANDROID_PROMPT_INFO' is not well formed\"\n                )\n//                moshi.adapter(AndroidPromptInfo::class.java).fromJsonValue(it)\n//                        ?: throw MethodCallException(\n//                                \"BadArgument\",\n//                                \"'$PARAM_ANDROID_PROMPT_INFO' is not well formed\"\n//                        )\n            }\n        }\n        val getName = { requiredArgument<String>(PARAM_NAME) }\n        val getContent = { requiredArgument<String>(PARAM_WRITE_CONTENT) }\n        fun withStorage(cb: StorageItem.() -> Unit) {\n            val name = getName()\n            storageItems[name]?.apply(cb) ?: return {\n                result.error(AuthenticationError.NotInitialized.toString(), \"Storage $name was not initialized.\", null)\n            }()\n        }\n        when (call.method) {\n            \"canAuthenticate\" -> result.success(canAuthenticate().toString())\n            \"getPlatformVersion\" -> result.success(\"test Android ${android.os.Build.VERSION.RELEASE}\")\n            \"init\" -> {\n\n                try {\n                    val gson = Gson()\n//                    val options = moshi.adapter<InitOptions>(InitOptions::class.java)\n//                        .fromJsonValue(call.argument(\"options\") ?: emptyMap<String, Any>())\n//                        ?: InitOptions()\n                    val options = gson.fromJson(call.argument(\"options\") ?: emptyMap<String, Any>().toString(), InitOptions::class.java)\n                    storageItems[getName()] = StorageItem(getName(), options)\n\n                    var prefs = PreferenceHelper.customPrefs(this.context, \"security-storage\")\n                    val json: String = prefs[getName()]\n                    storageItems[getName()]!!.encryptedData = gson.fromJson(json, EncryptedData::class.java)\n                } catch (e: Throwable) {\n                    Log.e(TAG, \"OcurriÃ³n un error al inicializar el storage: ${e.message}\")\n                }\n\n            }\n            \"write\" -> {\n\n                withStorage {\n                    val name = getName()\n                    val content = getContent()\n                    promptInfo = createPromptInfo(getAndroidPromptInfo())\n                    biometricPrompt = createBiometricPrompt({\n                        processDataEncrypt(name, it.cryptoObject, content) { data ->\n                            saveAvailableState(true)\n                            result.success(data)\n                        }\n                    }, {\n                        result.error(it.error.toString(), it.message.toString(), it.errorDetails)\n                    }, getContent())\n                    authenticateToEncrypt(getName(), getContent()) {\n                        result.error(it.error.toString(), it.message.toString(), it.errorDetails)\n                    }\n                }\n            }\n            \"read\" -> {\n\n                val name = getName()\n\n                var prefs = PreferenceHelper.customPrefs(this.context, \"security-storage\")\n\n                if (prefs.contains(name)) {\n                    withStorage {\n                        if (exists()) {\n                            promptInfo = createPromptInfo(getAndroidPromptInfo())\n                            biometricPrompt = createBiometricPrompt({\n                                processDataDecrypt(name, it.cryptoObject) { data ->\n                                    result.success(data)\n                                }\n                            }, {\n\n                                result.error(it.error.toString(), it.message.toString(), it.errorDetails)\n                            })\n                            authenticateToDecrypt(getName()) {\n                                result.error(it.error.toString(), it.message.toString(), it.errorDetails)\n                            }\n                        } else {\n                            result.success(null);\n                        }\n\n                    }\n                } else {\n                    result.success(null);\n                }\n            }\n            \"delete\" -> {\n                val name = getName()\n                var prefs = PreferenceHelper.customPrefs(this.context, \"security-storage\")\n\n                withStorage {\n                    if (exists()) {\n                        prefs.edit().remove(name).commit();\n                        storageItems.remove(name)\n                        cryptographyManager.removeStore(name)\n                        saveAvailableState(false)\n                        result.success(true);\n\n                    } else {\n                        result.success(false);\n                    }\n\n                }\n            }\n            \"isAvailableInApp\" -> {\n                if (isAvailableInApp()) {\n                    result.success(true);\n                } else {\n                    result.success(false);\n                }\n            }\n            \"isAvailableBiometricBanner\" -> {\n                if (isAvailableBiometricBanner()) {\n                    result.success(true);\n                } else {\n                    result.success(false);\n                }\n            }\n            \"getIconString\" -> {\n                result.success(\"touch_icon\");\n            }\n            else -> result.notImplemented()\n        }\n\n    }\n\n    private fun isAvailableInApp(): Boolean {\n        var prefs = PreferenceHelper.customPrefs(this.context, \"security-storage\")\n        return prefs.getBoolean(\"isAvailableInApp\", false)\n    }\n\n    private fun isAvailableBiometricBanner(): Boolean {\n        if (canAuthenticate() == CanAuthenticateResponse.Success) {\n            var prefs = PreferenceHelper.customPrefs(this.context, \"security-storage\")\n            val isAvailableBiometricBanner = prefs.getBoolean(\"isAvailableBiometricBanner\", false)\n            if (!isAvailableBiometricBanner) {\n                saveAvailableBiometricBannerState(true)\n            }\n            return !isAvailableInApp() && !isAvailableBiometricBanner\n        } else {\n            return false\n        }\n    }\n\n    private fun saveAvailableBiometricBannerState(value: Boolean) {\n        var prefs = PreferenceHelper.customPrefs(this.context, \"security-storage\")\n        val sharedPref = prefs ?: return\n        with(sharedPref.edit()) {\n            putBoolean(\"isAvailableBiometricBanner\", value)\n            apply()\n        }\n    }\n\n    private fun deleteData(name: String, onSuccess: (Boolean) -> Unit) {\n        var prefs = PreferenceHelper.customPrefs(this.context, \"security-storage\")\n\n        prefs.edit().remove(name).commit();\n        storageItems.remove(name)\n        cryptographyManager.removeStore(name)\n        saveAvailableState(false)\n        onSuccess(true)\n    }\n\n    private fun saveAvailableState(value: Boolean) {\n        var prefs = PreferenceHelper.customPrefs(this.context, \"security-storage\")\n        val sharedPref = prefs ?: return\n        with(sharedPref.edit()) {\n            putBoolean(\"isAvailableInApp\", value)\n            apply()\n        }\n    }\n\n    private fun canAuthenticate(): CanAuthenticateResponse {\n        var response = BiometricManager.from(this.context).canAuthenticate()\n        return CanAuthenticateResponse.values().firstOrNull { it.code == response }\n                ?: throw Exception(\"Unknown response code {$response} (available: ${CanAuthenticateResponse.values()}\")\n    }\n\n    private fun createBiometricPrompt(onSuccess: (result: BiometricPrompt.AuthenticationResult) -> Unit, onError: ErrorCallback, data: String = \"\"): BiometricPrompt {\n        val callback = object : BiometricPrompt.AuthenticationCallback() {\n            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                super.onAuthenticationError(errorCode, errString)\n                Log.d(TAG, \"$errorCode :: $errString\")\n                ui(onError) { onError(AuthenticationErrorInfo(AuthenticationError.forCode(errorCode), errString)) }\n            }\n\n            override fun onAuthenticationFailed() {\n                super.onAuthenticationFailed()\n                Log.d(TAG, \"Authentication failed for an unknown reason\")\n            }\n\n            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                super.onAuthenticationSucceeded(result)\n                Log.d(TAG, \"Authentication was successful\")\n\n                ui(onError) {\n                    onSuccess(result)\n                }\n            }\n        }\n\n        return BiometricPrompt(activity, executor, callback)\n    }\n\n    private fun createPromptInfo(promptInfo: AndroidPromptInfo): BiometricPrompt.PromptInfo {\n        return BiometricPrompt.PromptInfo.Builder()\n                .setTitle(promptInfo.title) // e.g. \"Sign in\"\n                .setSubtitle(promptInfo.subtitle) // e.g. \"Biometric for My App\"\n                .setDescription(promptInfo.description) // e.g. \"Confirm biometric to continue\"\n                .setConfirmationRequired(promptInfo.confirmationRequired)\n                .setNegativeButtonText(promptInfo.negativeButton) // e.g. \"Use Account Password\"\n                // .setDeviceCredentialAllowed(true) // Allow PIN/pattern/password authentication.\n                // Also note that setDeviceCredentialAllowed and setNegativeButtonText are\n                // incompatible so that if you uncomment one you must comment out the other\n                .build()\n    }\n\n    private fun authenticateToEncrypt(secretKeyName: String, content: String, onError: ErrorCallback) {\n        if (BiometricManager.from(this.context).canAuthenticate() == BiometricManager.BIOMETRIC_SUCCESS) {\n            var options = storageItems[secretKeyName]!!.options;\n            cryptographyManager.getInitializedCipherForEncryption(secretKeyName, options!!, {\n                biometricPrompt.authenticate(promptInfo, BiometricPrompt.CryptoObject(it))\n\n            }, {\n                Log.d(TAG, it.message.toString())\n                var errorType = AuthenticationError.Unknown\n                if (it is KeyPermanentlyInvalidatedException) {\n                    cryptographyManager.removeStore(secretKeyName)\n                    errorType = AuthenticationError.KeyPermanentlyInvalidated\n                }\n                if (it is InvalidAlgorithmParameterException) {\n                    errorType = AuthenticationError.NoBiometricEnrolled\n                }\n                ui(onError) {\n                    onError(AuthenticationErrorInfo(errorType, it.message.toString()))\n                }\n            })\n        }\n\n    }\n\n    private fun authenticateToDecrypt(secretKeyName: String, onError: ErrorCallback) {\n        if (BiometricManager.from(this.context).canAuthenticate() == BiometricManager.BIOMETRIC_SUCCESS) {\n            if (storageItems[secretKeyName]!!.encryptedData == null) {\n                var prefs = PreferenceHelper.customPrefs(this.context, \"security-storage\")\n                val json: String = prefs[secretKeyName]\n                val gson = Gson()\n                storageItems[secretKeyName]!!.encryptedData = gson.fromJson(json, EncryptedData::class.java)\n            }\n            var initializationVector: ByteArray? = storageItems[secretKeyName]?.encryptedData?.initializationVector\n            var options = storageItems[secretKeyName]?.options\n            Log.d(secretKeyName, initializationVector.toString())\n            cryptographyManager.getInitializedCipherForDecryption(secretKeyName, initializationVector, options!!, {\n                biometricPrompt.authenticate(promptInfo, BiometricPrompt.CryptoObject(it))\n            }, {\n                Log.d(TAG, it.message.toString())\n                var errorType = AuthenticationError.Unknown\n                if (it is KeyPermanentlyInvalidatedException) {\n                    errorType = AuthenticationError.KeyPermanentlyInvalidated\n                }\n                if (it is InvalidAlgorithmParameterException) {\n                    errorType = AuthenticationError.NoBiometricEnrolled\n                }\n                ui(onError) {\n                    onError(AuthenticationErrorInfo(errorType, it.message.toString()))\n                }\n\n\n            })\n\n        }\n    }\n\n    private fun authenticateToRemove(secretKeyName: String, onError: ErrorCallback) {\n        if (BiometricManager.from(this.context).canAuthenticate() == BiometricManager.BIOMETRIC_SUCCESS) {\n\n            var initializationVector: ByteArray? = storageItems[secretKeyName]?.encryptedData?.initializationVector\n            var options = storageItems[secretKeyName]?.options\n            if (initializationVector != null) {\n                cryptographyManager.getInitializedCipherForDecryption(secretKeyName, initializationVector, options!!, {\n                    biometricPrompt.authenticate(promptInfo, BiometricPrompt.CryptoObject(it))\n                }, {\n                    Log.d(TAG, it.message.toString())\n                    var errorType = AuthenticationError.Unknown\n                    if (it is KeyPermanentlyInvalidatedException) {\n                        cryptographyManager.removeStore(secretKeyName)\n                        errorType = AuthenticationError.KeyPermanentlyInvalidated\n                    }\n                    if (it is InvalidAlgorithmParameterException) {\n                        errorType = AuthenticationError.NoBiometricEnrolled\n                    }\n                    ui(onError) {\n                        onError(AuthenticationErrorInfo(errorType, it.message.toString()))\n                    }\n                })\n\n            } else {\n                ui(onError) {\n                    onError(AuthenticationErrorInfo(AuthenticationError.Failed, \"the key is not configured\", \"\"))\n                }\n            }\n\n        }\n    }\n\n    private fun processDataEncrypt(secretKeyName: String, cryptoObject: BiometricPrompt.CryptoObject?, data: String, onSuccess: (String) -> Unit) {\n\n        val encryptedData = cryptographyManager.encryptData(data, cryptoObject?.cipher!!)\n        storageItems[secretKeyName]?.encryptedData = encryptedData\n\n        val gson = Gson()\n        val json: String = gson.toJson(encryptedData)\n        var prefs = PreferenceHelper.customPrefs(this.context, \"security-storage\")\n        prefs.edit()\n        prefs[secretKeyName] = json\n\n        val data = String(encryptedData.ciphertext, Charset.forName(\"UTF-8\"))\n        onSuccess(data)\n\n    }\n\n    private fun processDataDecrypt(secretKeyName: String, cryptoObject: BiometricPrompt.CryptoObject?, onSuccess: (String) -> Unit) {\n        var cipherText = storageItems[secretKeyName]?.encryptedData?.ciphertext\n        val data = cryptographyManager.decryptData(cipherText!!, cryptoObject?.cipher!!)\n        onSuccess(data)\n    }\n\n    override fun onDetachedFromEngine(@NonNull binding: FlutterPlugin.FlutterPluginBinding) {\n        channel.setMethodCallHandler(null)\n    }\n\n    override fun onDetachedFromActivity() {\n        //TODO(\"Not yet implemented\")\n    }\n\n    override fun onReattachedToActivityForConfigChanges(binding: ActivityPluginBinding) {\n        //TODO(\"Not yet implemented\")\n    }\n\n    override fun onAttachedToActivity(binding: ActivityPluginBinding) {\n        updateAttachedActivity(binding.activity)\n    }\n\n    private fun updateAttachedActivity(activity: Activity) {\n        if (activity !is FragmentActivity) {\n            //logger.error { \"Got attached to activity which is not a FragmentActivity: $activity\" }\n            Log.e(TAG, \"Got attached to activity which is not a FragmentActivity: $activity\")\n            return\n        }\n        this.activity = activity\n    }\n\n    override fun onDetachedFromActivityForConfigChanges() {\n        //TODO(\"Not yet implemented\")\n    }\n\n    private inline fun ui(crossinline onError: ErrorCallback, crossinline cb: () -> Unit) = handler.post {\n        try {\n            cb()\n        } catch (e: Throwable) {\n            Log.e(TAG, \"Error while calling UI callback. This must not happen.\")\n            onError(AuthenticationErrorInfo(AuthenticationError.Unknown, \"Unexpected authentication error. ${e.localizedMessage}\", e))\n        }\n    }\n}\ntypealias ErrorCallback = (errorInfo: AuthenticationErrorInfo) -> Unit\n\n@Suppress(\"unused\")\nenum class AuthenticationError(val code: Int) {\n    Canceled(BiometricPrompt.ERROR_CANCELED),\n    Timeout(BiometricPrompt.ERROR_TIMEOUT),\n    UserCanceled(BiometricPrompt.ERROR_USER_CANCELED),\n    Lockout(BiometricPrompt.ERROR_LOCKOUT),\n    LockoutPermanent(BiometricPrompt.ERROR_LOCKOUT_PERMANENT),\n    NegativeButton(BiometricPrompt.ERROR_NEGATIVE_BUTTON),\n    KeyPermanentlyInvalidated(-3),\n    Unknown(-1),\n\n    /** Authentication valid, but unknown */\n    Failed(-2),\n    NotInitialized(-4),\n    NoBiometricEnrolled(-5)\n    ;\n\n    companion object {\n        fun forCode(code: Int) =\n                values().firstOrNull { it.code == code } ?: Unknown\n    }\n}\n\ndata class AuthenticationErrorInfo(\n        val error: AuthenticationError,\n        val message: CharSequence,\n        val errorDetails: String? = null\n) {\n    constructor(\n            error: AuthenticationError,\n            message: CharSequence,\n            e: Throwable\n    ) : this(error, message, e.toString())\n}\n\n//@JsonClass(generateAdapter = true)\ndata class AndroidPromptInfo(\n        val title: String,\n        val subtitle: String?,\n        val description: String?,\n        val negativeButton: String,\n        val confirmationRequired: Boolean\n)\n\n\nclass MethodCallException(\n        val errorCode: String,\n        val errorMessage: String?,\n        val errorDetails: Any? = null\n) : Exception(errorMessage ?: errorCode)\n\n\ndata class StorageItem(\n        val name: String,\n        val options: InitOptions? = null,\n        var encryptedData: EncryptedData? = null\n) {\n    constructor(name: String, options: InitOptions) : this(name, options, null)\n\n    fun exists(): Boolean {\n        return (this.options !== null && this.encryptedData !== null);\n    }\n}\n\nenum class CanAuthenticateResponse(val code: Int) {\n    Success(BiometricManager.BIOMETRIC_SUCCESS),\n    ErrorHwUnavailable(BiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE),\n    ErrorNoBiometricEnrolled(BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED),\n    ErrorNoHardware(BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE),\n    ErrorSecurityUpdateRequired(BiometricManager.BIOMETRIC_ERROR_SECURITY_UPDATE_REQUIRED),\n    ErrorUnsupported(BiometricManager.BIOMETRIC_ERROR_UNSUPPORTED),\n    ErrorStatusUnknown(BiometricManager.BIOMETRIC_STATUS_UNKNOWN)\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/kotlin/com/pacificoseguros/securitystorage/security_storage/SecurityStoragePlugin.kt b/src/main/kotlin/com/pacificoseguros/securitystorage/security_storage/SecurityStoragePlugin.kt
--- a/src/main/kotlin/com/pacificoseguros/securitystorage/security_storage/SecurityStoragePlugin.kt	(revision 03afc8d83b283d68456ca13ca7cf6f1ad91f4cc3)
+++ b/src/main/kotlin/com/pacificoseguros/securitystorage/security_storage/SecurityStoragePlugin.kt	(date 1656816083010)
@@ -16,7 +16,7 @@
 //import com.squareup.moshi.Moshi
 //import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
 import io.flutter.embedding.engine.plugins.FlutterPlugin
-import io.flutter.embedding.engine.plugins.activity.ActivityAware
+import io.flutter.embedding.engine.pluginis.activity.ActivityAware
 import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding
 import io.flutter.plugin.common.MethodCall
 import io.flutter.plugin.common.MethodChannel
@@ -85,13 +85,18 @@
 
     override fun onMethodCall(@NonNull call: MethodCall, @NonNull result: Result) {
 
-        fun <T> requiredArgument(name: String) =
-                call.argument<T>(name) ?: throw MethodCallException(
-                        "MissingArgument",
-                        "Missing required argument '$name'"
+        fun <T> requiredArgument(name: String) {
+            val argValue = call.argument<T>(name)
+            if (!argValue) {
+                throw MethodCallException(
+                    "MissingArgument",
+                    "Missing required argument '$name'"
                 )
+            }
+            return argValue as T
+        }
 
-        val getAndroidPromptInfo = {
+        val getAndroidPromptInfo: () -> AndroidPromptInfo = {
             val gson = Gson()
             requiredArgument<Map<String, Any>>(PARAM_ANDROID_PROMPT_INFO).let {
                 gson.fromJson(it ?: "{}", AndroidPromptInfo::class.java) ?: throw MethodCallException(
